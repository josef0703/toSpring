# 서블릿
- 서블릿과 자바 코드만으로 HTML을 만들게 되면 복잡하고 비효율적임

# JSP
- ```<%@ page contentType="text/html;charset=UTF-8" language="java" %>``` 
- JSP 문서라는 뜻으로 첫줄에 넣어줘야 함

## 서블릿과 JSP의 한계
- 서블릿으로 개발할 때는 HTML 만드는 작업을 자바 코드로 하기때문에 지전분하고 복잡함
- JSP는 HTML 작업은 깔끔해졌지만 비즈니스 로직,HTML 뷰 역할등 JSP가 너무 많은 역할을 함

# MVC(Model View Controller) 패턴
- 서블릿,JSP로 처리했던 것들을 컨트롤러와 뷰 영역으로 역할을 나누는 것을 MVC 패턴이라 함.

컨트롤러 : HTTP 요청 받아 파라미터 검증, 비즈니스 로직 실행(서비스 계층), 데이터 조회하여 모델이 담음
모델 : 뷰에 출력할 데이터를 담아둠.
뷰 : 모델에 담겨있는 데이터 사용하여 화면 랜더링 

![image](https://user-images.githubusercontent.com/59104703/168729736-a4af4922-7eae-457c-867c-3c38e43fa75b.png)

![image](https://user-images.githubusercontent.com/59104703/168729727-b1788163-c6c4-4ba9-902f-e98c55ac869d.png)

## MVC 패턴 적용
- ```/WEB-INF``` 이 경로안에 JSP가 있으면 외부에서 직접 호출X
- ```dispatcher.forward()``` : 다른 서블릿이나 JSP로 이동할 수 있는 기능. 서버 내부에서 다시 호출 발생
- ```request.setAttribute("member", member);```
- HttpServletRequest를 Model로 사용
- ```request.getAttribute()```로 데이터 꺼내면 됨

## MVC 패턴 한계
- 포워드 중복
  - ```dispatcher.forward(request, response);```
- ViewPath 중복
  - ```String viewPath = "/WEB-INF/views/new-form.jsp";```
- 사용하지 않는 코드
  - ```HttpServletRequest request, HttpServletResponse response```
- 공통 처리 어려움

# 프론트 컨트롤러
![image](https://user-images.githubusercontent.com/59104703/168731357-d3397749-ee97-40e2-ba85-ca485d163098.png)
- 서블릿 하나로 클라이언트의 요청을 받음
- 요청에 맞는 컨트롤러를 찾아서 호출
- 공통 처리 가능

# 프론트 컨트롤러 도입 - V1
![image](https://user-images.githubusercontent.com/59104703/168731684-41173c99-0a0a-4148-9fbe-3c7e59381c01.png)
<pre>
public interface ControllerV1 {
 void process(HttpServletRequest request, HttpServletResponse response)
throws ServletException, IOException;
}
</pre>
- 서블릿과 비슷한 모양의 컨트롤러 인터페이스 도입
- 각 컨트롤러는 인터에피스 구현하면 됨
- 
<pre>
controllerMap.put("/front-controller/v1/members/new-form", new MemberFormControllerV1());
 controllerMap.put("/front-controller/v1/members/save", new MemberSaveControllerV1());
 controllerMap.put("/front-controller/v1/members", new MemberListControllerV1());

String requestURI = request.getRequestURI();
 ControllerV1 controller = controllerMap.get(requestURI);
 
 controller.process(request, response);

</pre>
1.  ```request.getRequestURI()```를 통해 URL("/front-controller/v1/members") 가져옴
2.  URL 키값을 통해 new MemberListControllerV1() 객체 반환 후 controller 변수에 저장(다형성 때문에 가능)
3.  MemberListControllerV1()의 process 메소드 호출
4.  JSP 호출


# View 분리 - V2
![image](https://user-images.githubusercontent.com/59104703/168734076-90121ea7-eba3-4037-b1ad-b2352200917b.png)

**뷰로 이동하는 중복 코드**
<pre>
String viewPath = "/WEB-INF/views/new-form.jsp";
RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
dispatcher.forward(request, response);
</pre>

**Myview**
<pre>
private String viewPath;
 public MyView(String viewPath) {
 this.viewPath = viewPath;
 }
 
 public void render(HttpServletRequest request, HttpServletResponse
response) throws ServletException, IOException {
 RequestDispatcher dispatcher = request.getRequestDispatcher(viewPath);
 dispatcher.forward(request, response);
 }
</pre>

**MemberFormControllerV2**
<pre>
public MyView process(HttpServletRequest request, HttpServletResponse
response) throws ServletException, IOException {
 return new MyView("/WEB-INF/views/new-form.jsp");
 }
</pre>
## V1과 V2의 차이점
- V1는 Controller에서 바로 JSP 호출
- V2는 중복코드를 제거하기 위해 ```Controller```에서 ```Myview```를 반환하고 ```Myview```에서 ```render```을 통해 JSP 호출
- ```Myview```객체의```render()```을 통해 중복 코드 제거
- 각 컨트롤러는 ```Myview```객체를 생성 후 반환하는 역할만 하면 됨.


# Model 추가 - V3

![image](https://user-images.githubusercontent.com/59104703/168736385-0dad4327-b7c2-4f7b-9759-111aaab4a043.png)

- 서블릿 종속성 제거
- 뷰 이름 중복 제거
  - <pre>
    public ModelView process(Map<String, String> paramMap) {
      return new ModelView("new-form");
     }
    </pre>
  - ```new-form```이라는 view의 논리적인 이름만 지정
- ModelView




